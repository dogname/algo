#+html_head: <link rel="stylesheet" type="text/css" href="/home/ticks/Public/org_style.css" />
#+title: 红黑树

* 红黑树 
** 红黑树的介绍
红黑树是一种特殊的二叉搜索树, 每个节点多出了一个颜色属性,并满足一下 5 条性质
1. 每个节点或者是黑色，或者是红色
2. 根节点是黑色的
3. 空的叶子节点是黑色的
4. 红色节点的孩子是黑色的
5. 每个节点到叶子的路径包含相同的黑色节点
** 红黑树的性质
  *引理*
#+BEGIN_QUOTE
n 个内部节点的红黑树最大高度为 $2log_2(n+1)$
#+END_QUOTE
*证明*
#+BEGIN_PROOF
先证以 x 为根的子树最少有 $2^{bh(x)}-1$ 个内部节点. 

1. 当 x 为空的叶子节点时, 以 x 为根的子树有 $2^0-1=0$ 个内部节点, 满足.
2. 当 x 有两个内部孩子节点时, 孩子节点的黑色高度(black-height)为 bh(x) (/* 当 x 为红色节点*/)  或者为 bh(x) -1 (/* 当 x 为黑色节点  */)
3. 所以 x 的节点数目 $n\geqslant 2^{bh(x)-1}-1+2^{bh(x)-1}-1+1=2^{bh(x)}-1$
4. 又 $bh(x)\geqslant h/2$, 所以 $n\geqslant 2^{h/2}-1$
5. 所以 $h\leqslant 2log_2(n+1)$
#+END_PROOF

** 旋转

左旋
1. x 右孩子 y 的左孩子成为 x 的右孩子
2. x 成为 y 的左孩子
3. y 取代 x 的位置

右旋
1. x 左孩子 y 的右孩子成为 x 的左孩子
2. x 成为 y 的右孩子
3. y 取代 x 的位置

file:right.png
file:left.png
** 插入
1. 根据 key 值的大小插入新的节点 z, 颜色为红色
2. 若插入的是根节点, 只需要把根设为黑色
3. 若插入节点 z 的 parent 是红色的
   1. z 的 uncle 是红色的, 将 parent 和 uncle 设为黑色, grandparent 设为红色, 将 grandparent 当成插入节点, 重新判断
   2. z 的 uncle 是黑色的(tip. T.nil 也是黑色的), 将 z 到 uncle 的路径调为人形, parent 设为黑色 grandparent 设为红色, 将 grandparent 向 uncle 方向旋转
#+BEGIN_SRC C++
template <typename T>
void RBTree<T>::leftRoate(RBNode<T>* x)
{
	RBNode<T>* y = x->right;
	x->right     = y->left;
	if (x->right) x->right->parent = x;
	y->parent = x->parent;
	if (!y->parent)
		root = y;
	else if (y->parent->left == x)
		y->parent->left = y;
	else
		y->parent->right = y;
	y->left   = x;
	x->parent = y;
}

template <typename T>
void RBTree<T>::rightRoate(RBNode<T>* x)
{
	RBNode<T>* y = x->left;
	x->right     = y->left;
	if (y->left) y->left->parent = y;
	y->parent = x->parent;
	if (!y->parent)
		root = y;
	else if (y->parent->left == x)
		y->parent->left = y;
	else
		y->parent->right = y;
	y->right  = x;
	x->parent = y;
}

template <typename T>
void RBTree<T>::insert(T key)
{
	RBNode<T>* z  = new RBNode<T>(RED, key, nullptr, nullptr, nullptr);
	RBNode<T>* px = root;
	RBNode<T>* py = nullptr;
	while (root)
	{
		py = px;
		if (key < px->key)
			px = px->left;
		else
			px = px->right;
	}
	z->parent = py;
	if (!py)
		root = z;
	else if (z->key < py->key)
		py->left = z;
	else
		py->right = z;
	insertFix(z);
}

template <typename T>
void RBTree<T>::insertFix(RBNode<T>* z)
{
	while (z->parent && z->parent->color == RED)
	{
		if (z->parent == z->parent->parent->left)
		{
			RBNode<T>* uncle = z->parent->parent->right;
			if (uncle && uncle->color == RED)
			{
				uncle->color             = BLACK;
				z->parent->color         = BLACK;
				z->parent->parent->color = RED;
				z                        = z->parent->parent;
			}
			else if (z == z->parent->right)
			{
				z = z->parent;
				leftRoate(z);
			}
			z->parent->color         = BLACK;
			z->parent->parent->color = RED;
			rightRoate(z->parent->parent);
		}
		else
		{
			RBNode<T>* uncle = z->parent->parent->left;
			if (uncle && uncle->color == RED)
			{
				uncle->color             = BLACK;
				z->parent->color         = BLACK;
				z->parent->parent->color = RED;
				z                        = z->parent->parent;
			}
			else if (z == z->parent->left)
			{
				z = z->parent;
				rightRoate(z);
			}
			z->parent->color         = BLACK;
			z->parent->parent->color = RED;
			leftRoate(z->parent->parent);
		}
	}
	root->color = BLACK;
}

#+END_SRC

** 删除   
*** 子树替换的辅助程序
#+BEGIN_SRC C++
  template <typename T>
  void RBTree<T>::transSubtree(RBNode<T>* src, RBNode<T>* dic)
  {
    if (!src->parent)
      root = dic;
    else if (src == src->parent->left)
      src->parent->left = dic;
    else
      src->parent->right = dic;
    if (dic) dic->parent = src->parent;
  }
#+END_SRC

*** 删除节点 z
1. z 的孩子小于 2 个. =y = x=, =x = z->child=
2. z 有 2 个孩子. 两个指针 x, y; y 总是指向 z 或 z 的后继. x 总是指向 y 的替代者. 保存 y 的原始颜色
 =y = successor(z)=, =x = y->right=
#+BEGIN_SRC C++
  template <typename T>
  void RBTree<T>::remove(RBNode<T>* z)
  {
    if (!z->left)
    {
      transSubtree(z, z->right);
    }
    else if (!z->right)
    {
      transSubtree(z, z->left);
    }
    else
    {
      RBNode<T>* y = successor(z);
      RBNode<T>* x = y->right;

      RBColor yOriginalCol = y->color;
      if (y->parent == z)
        x->parent = y;
      else
      {
        transSubtree(y, x);
        y->right         = z->right;
        y->right->parent = y;
      }
      transSubtree(z, y);
      y->left         = z->left;
      y->left->parent = y;
      delete z;
      if (yOriginalCol == BLACK) removeFix(x);
    }
  }
#+END_SRC

*** 修复红黑树, 使其满足 5 条性质
