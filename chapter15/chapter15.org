#+html_head: <link rel="stylesheet" type="text/css" href="/home/ticks/Public/org_style.css" />
#+options: creator:t author:t email:t
#+author: ticks
#+title: 动态规划(dynamic programing)
#+email: xiehuiwu1996@gmail.com
* 钢条切割
给长度为 n 的钢条和一个价格表 $p_i$, 如何切割收益最大
** 普通递归
收益 $r_n=max(r_i+r_{n-i})$
#+BEGIN_EXAMPLE
CUT-ROD(p, n)
1   if n == 0
2       return 0
3   q = -1
4   for i = 1 to n
5       q = max(q, p[i] + CUT-ROD(p, n-i))
6   return q
#+END_EXAMPLE
$$T(n)=1+\sum_{i=0}^{n-1}T(i) = 2^n$$

** 动规
#+BEGIN_EXAMPLE
CUT-ROD(p, n, r)
1   if r[n] > 0
2       return r[n]
3   if n == 0
4      return 0
5   q = 0
6   for i = 1 to n
7       q = max(q, p[i] + CUT-ROD(p, n-i))
8   r[n] = q
9   return q
#+END_EXAMPLE

或者
#+BEGIN_EXAMPLE
CUT-ROD(p, n)
1   let r[1...n] be a new array
2   r[0] = 0
3   for i = 1 to n
4       q = 0
6       for j = 1 to i
7           q = max(q, p[j] + r[i-j])
8       r[i] = q
9   return r[n]
#+END_EXAMPLE

** 子问题图
#+BEGIN_SRC dot :cmdline -T png -Kdot :file subG.png
  digraph G{
    4->3->2->1->0
    4->2
    4->1
    4->0
    3->1
    3->0
    2->0
  }
#+END_SRC

#+RESULTS:
[[file:subG.png]]

** 练习
*** 
$T(0)=1=2^0$
假设 n 小于 N 的时候满足 $T(n)=2^n$
则$$T(N)=1+\sum_{j=0}^{N-1}T(j)=1+\sum_{j=0}^{N-1}2^j=1+(2^N-1)=2^N$$
*** 
$p = {0.5, 1, 1.5, 12, 20}, n =8$

贪心结果 5+3, 收益 20+1.5=21.5

最优 4+4, 收益 12+12=24
***  
#+BEGIN_EXAMPLE
CUT-ROD(p, n, cost)
1   let r[1...n] be a new array
2   r[0] = 0
3   for i = 1 to n
4       q = 0
6       for j = 1 to i - 1
7           q = max(q, p[j] + r[i - j] - cost)
8       if(q < p[i] 
9           q = p[i]
10      r[i] = q
11  return r[n]
#+END_EXAMPLE

*** 
略
*** 
#+BEGIN_EXAMPLE
fbi(n)
1   res[3] = {1, 1, 2}
2   for(int i = 3; i < n; ++i)
3       res[i % 3] = res[(i + 1) % 3]+res[(i + 2) % 3]
4   return res[(n - 1) % 3]
#+END_EXAMPLE

#+BEGIN_SRC dot :file fbi.png :cmdline -Tpng -Kdot
  digraph G{
    6->5
    6->4
    5->4
    5->3
    4->3->2
    4->2
    3->1
    }
#+END_SRC

#+RESULTS:
[[file:fbi.png]]

n 个顶点, 2n-4 条边

* 矩阵链乘法
$A_{p\times q}\cdot B_{q\times r}=C_{p\times r}$ 用标量乘法的次数来表复杂度的话, 该矩阵乘法的代价 $pqr$
** 动态规划
1. 递归公式 $m_{i,j}$ 表示 $A_iA_{i+1}\cdots A_j$ 的代价
\[m_{i,j}=\begin{cases}0,&i=j\\min\{m_{i,k}+m_{k+1,j}+p_{i-1}p_kp_j\},&i< j\end{cases}\]

#+BEGIN_EXAMPLE
  MATRIX-CHAIN-ORDER(p)
  1   n = p.length - 1
  2   let m[1,2,...,n;1,2,...n] and s[1,2,...,n-1;2,3,...,n] be a new array
  3   for i = 1 to n
  4       m[i, i] = 0
  5   for l = 2 to n
  6       for i = 1 to n - l + 1
  7           j = i + l - 1
  8           m[i, j] = ∞
  9           for k = 1 to j - 1
  10              q = m[i, k] + m[k + 1, j] + p_{i-1}p_kp_j
  11              if q < m[i, j]
  12                  m[i, j] = q
  13                  s[i, j] = k
  14   return m and s
#+END_EXAMPLE

** 练习
*** 
$$((A_1A_2)((A_3A_4)(A_5A_6)))$$
*** 
#+BEGIN_EXAMPLE
MATRIX-MULTIPLY(A, B)
1   if A.cols != B.rows
2       error "维度错误"
3   else let C be a new A.rows X B.cols matrix initialise with 0
4       for i  = 1 to A.rows
5           for j = 1 to B.cols
6               for k = 1 to A.cols
7                   C[i][j] += A[i][k]*B[k][j]
8   return C

MATRIX-CHAIN-MULTIPLY(A, s, i, j)
1   if i == j
2       return A[i]
3   return MATRIX-MULTIPLY(MATRIX-CHAIN-MULTIPLY(A, s, i, s[i][j]), MATRIX-CHAIN-MULTIPLY(A, s, i, s[i][j]))
#+END_EXAMPLE

*** 
$$P(n+1) = \sum_{j=0}^{n}P(j)P(n+1-j)=P(n)+\sum_{j=1}^{n-1}P(j)P(n+1-j)\geqslant P(n)+\sum_{j=1}^{n-1}P(j)P(n-j)=2P(n)\geqslant 2*2^n=2^{n+1}$$
*** 
略
*** 
\[\sum_{i=1}^{n}\sum_{j=1}^{n}R(i,j)=\sum_{l=2}^{n}\sum_{i=1}^{n-l-1} 2(l-1)=_{k=l-1}\sum_{k=1}^{n-1}2nk-2k^2=\frac{n^3-n}{3}\]
    

*** 
一对括号意为着一次乘法, n 个元素需要 n-1 次乘法, 需要 n-1 对括号
* 动态规划原理
** 最优子结构
*** 无权最短路径是有最优子结构的
*** 无权最长路径没有最优子结构
** 重叠子问题
** 重构最优解
** 备忘

** 练习
*** 
穷举法书上给的下限为 $\Omega(\dfrac{4^n}{n^{3/2}})$

分治法

时间复杂度的递推公式
$$T(n)=\sum_{k=1}^{n-1}(T(k)+T(n-k)+O(1))+O(1)\leqslant 2\sum_{k=1}^{n-1}T(k)+a(n-1)+b$$
假设 $T(n)=O(3^n)$

可以假设 $T(N)\leqslant c3^n-d$, T(1)是常数,只要 C 足够大就行

假设 $k\in[1,n-1]$ 都满足 $T(k)\leqslant c3^n-d$, 则


$$\begin{aligned}T(n) &\leqslant 2\sum_{k-1}^{n-1}T(k)+a(n-1)+b \\&\leqslant 2\sum_{k=1}^{n-1}(c3^n-d)+a(n-1)+b \\&= c3^n-3c-2d(n-1)+a(n-1)+b\end{aligned}$$


取$d=a/2, c>\frac{b+d}{3}=\frac{2b+a}{6}$
$$T(n)\leqslant c3^n-d=O(3^n)$$
所以,分治法更有效率一点
*** 
#+BEGIN_SRC dot :file recursivetree.png :cmdline -Tpng -Kdot
  digraph G{
    a[label="1...16"]
    b[label="1...8"]
    c[label="9...16"]
    d[label="1...4"]
    e[label="5...8"]
    f[label="9...12"]
    g[label="13...16"]
    h[label="1...2"]
    i[label="3...4"]
    j[label="5...6"]
    k[label="7...8"]
    l[label="9...10"]
    m[label="11...12"]
    n[label="13...14"]
    o[label="15...16"]
    a->b
    a->c
    b->d
    b->e
    c->f
    c->g
    d->h
    d->i
    e->j
    e->k
    f->l
    f->m
    g->n
    g->o
    h->1
    h->2
    i->3
    i->4
    j->5
    j->6
    k->7
    k->8
    l->9
    l->10
    m->11
    m->12
    n->13
    n->14
    o->15
    o->16
  }
#+END_SRC

#+RESULTS:
[[file:recursivetree.png]]

这些子问题都没有重叠.
*** 
    有
*** 
p={5,6,8,4,3}
最优 $(A_1(A_2(A_3A_4)))$

Capulet 教授的方法

setp1. $((A_1A_2A_3)A_4)$

step2. $((A_1(A_2A_3))A_4)$
*** 
假设经过了中间货币 k , 那么 $R_{ij}=R_{ik}*R_{kj}$
若 $R_{ik} or R_{kj}$ 不是最优的,可以用更好的替换
* 最长公共子序列
** 子序列
一个序列 X=<x_1,x_2,$\cdots$,x_n}, 与另一个序列 Y=<y_1,y_2,$\cdots$,y_m} ,m < n; 若存在严格递增的下标序列 I<i_1,i_2,i$\cdots$,i_k>, 使得
x_{i_j}=y_j, $\all$j$\in$I. 称 Y 是 X 的子序列
** 公共子序列
若 Z 同时是 X 和 Y 的子序列, 称 Z 是 X 和 Y 的公共子序列

** 最长公共子序列 (longest-common-subsequebce, LCS) 问题
*** 最优子结构
设 $Z_k=LCS(X_m, Y_n)$.
$$\begin{cases}x_m=y_n, &Z_{k-1}=LCS(X_{m-1}, Y_{n-1})\\
x_m\neq y_n,&\begin{cases}
                          z_k\neq x_m, Z = LCS(X_{m-1}, Y_n)\\
                          z_k\neq y_n, Z = LCS(X_m,Y_n)
             \end{cases}
\end{cases}$$

#+BEGIN_SRC C++
  void lcsSolver(string& X, string& Y, vector<vector<int>>& c)
  {
    int m = X.size();
    int n = Y.size();
    for (int i = 0; i <= m; ++i) c[i][0] = 0;
    for (int j = 1; j <= n; ++j) c[0][j] = 0;
    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
      {
        if (X[i - 1] == Y[j - 1])
          c[i][j] = c[i - 1][j - 1] + 1;
        else
          c[i][j] = c[i - 1][j] < c[i][j - 1] ? c[i][j - 1] : c[i - 1][j];
      }
  }

  void printLCS(string& X, vector<vector<int>>& c, int i, int j)
  {
    if (i == 0 || j == 0) return;
    if (c[i][j] != c[i - 1][j] && c[i][j] != c[i][j - 1])
    {
      printLCS(X, c, i - 1, j - 1);
      cout << X[i - 1];
    }
    else if (c[i][j] == c[i - 1][j])
      printLCS(X, c, i - 1, j);
    else
      printLCS(X, c, i, j - 1);
  }
#+END_SRC

** 练习
*** 
<1,0,1,0,1,0>
*** 
见上面的 C++ 代码
*** 
#+BEGIN_EXAMPLE
MEMOIZED-LCS-LENGTH(X,Y)
1   n = X.length
2   m = Y.length
3   let c[0...n,0...m] be a new matrix and initialise with -1
4   return MEMOIZED-LCS-LENGTH-AUX(X, Y, c, n, m)

MEMOIZED-LCS-LENGTH-AUX(X, Y, c, i, j)
1   if c[i][j] >= 0 
2       return c[i][j]
3   if i==0 or j==0
4       c[i][j] = 0
5   elseif X[i] == Y[j]
6       c[i][j] == MEMOIZED-LCS-LENGTH-AUX(X, Y, c, i - 1, j - 1)
7   else
8       c[i][j] == max(MEMOIZED-LCS-LENGTH-AUX(X, Y, c, i - 1, j), MEMOIZED-LCS-LENGTH-AUX(X, Y, c, i, j - 1))
9   return c[i][j]
#+END_EXAMPLE
*** 
因为计算 C[i][j] 只需要本层数据和上层数据, 可以循环利用 cur 层 和 pre 层, 这样只需要 2min(m,n), 哪个元素多, 哪个优先

更进一步, c[i][j] 只需要上层数据和 C[i][j-1], 只需要一层和保存 c[i][j-1]的额外空间

*** 
   
#+BEGIN_EXAMPLE
MAX-LENGTH-SUBSQUEUE(A)
1   n = A.length
2   let L[1,...n] and P[1,...,n] be a new array
3   for i = 1 to n
4       L[i] = 1
5       P[i] = -1
6   for i = 2 to n
7       for j = 1 to i
8           if( A[j] < A[i] && L[j] + 1 > L[i]
9               L[i] = L[j] + 1
10              P[i] = j
11  return L and P

MAX-SUBSQUEUE-PRINT(A, P, i) // 最开始 i 是使 L(i) 最大的
1   if P[i] < 0
2       return
3   MAX-SUBSQUEUE-PRINT(A, P, P[i])

#+END_EXAMPLE
