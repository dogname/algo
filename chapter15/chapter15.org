#+html_head: <link rel="stylesheet" type="text/css" href="/home/ticks/Public/org_style.css" />
#+options: creator:t author:t email:t
#+author: ticks
#+title: 动态规划(dynamic programing)
#+email: xiehuiwu1996@gmail.com
* 钢条切割
给长度为 n 的钢条和一个价格表 $p_i$, 如何切割收益最大
** 普通递归
收益 $r_n=max(r_i+r_{n-i})$
#+BEGIN_EXAMPLE
CUT-ROD(p, n)
1   if n == 0
2       return 0
3   q = -1
4   for i = 1 to n
5       q = max(q, p[i] + CUT-ROD(p, n-i))
6   return q
#+END_EXAMPLE
$$T(n)=1+\sum_{i=0}^{n-1}T(i) = 2^n$$

** 动规
#+BEGIN_EXAMPLE
CUT-ROD(p, n, r)
1   if r[n] > 0
2       return r[n]
3   if n == 0
4      return 0
5   q = 0
6   for i = 1 to n
7       q = max(q, p[i] + CUT-ROD(p, n-i))
8   r[n] = q
9   return q
#+END_EXAMPLE

或者
#+BEGIN_EXAMPLE
CUT-ROD(p, n)
1   let r[1...n] be a new array
2   r[0] = 0
3   for i = 1 to n
4       q = 0
6       for j = 1 to i
7           q = max(q, p[j] + r[i-j])
8       r[i] = q
9   return r[n]
#+END_EXAMPLE

** 子问题图
#+BEGIN_SRC dot :cmdline -T png -Kdot :file subG.png
  digraph G{
    4->3->2->1->0
    4->2
    4->1
    4->0
    3->1
    3->0
    2->0
  }
#+END_SRC

#+RESULTS:
[[file:subG.png]]

** 练习
*** 
$T(0)=1=2^0$
假设 n 小于 N 的时候满足 $T(n)=2^n$
则$$T(N)=1+\sum_{j=0}^{N-1}T(j)=1+\sum_{j=0}^{N-1}2^j=1+(2^N-1)=2^N$$
*** 
$p = {0.5, 1, 1.5, 12, 20}, n =8$

贪心结果 5+3, 收益 20+1.5=21.5

最优 4+4, 收益 12+12=24
***  
#+BEGIN_EXAMPLE
CUT-ROD(p, n, cost)
1   let r[1...n] be a new array
2   r[0] = 0
3   for i = 1 to n
4       q = 0
6       for j = 1 to i - 1
7           q = max(q, p[j] + r[i - j] - cost)
8       if(q < p[i] 
9           q = p[i]
10      r[i] = q
11  return r[n]
#+END_EXAMPLE

*** 
略
*** 
#+BEGIN_EXAMPLE
fbi(n)
1   res[3] = {1, 1, 2}
2   for(int i = 3; i < n; ++i)
3       res[i % 3] = res[(i + 1) % 3]+res[(i + 2) % 3]
4   return res[(n - 1) % 3]
#+END_EXAMPLE

#+BEGIN_SRC dot :file fbi.png :cmdline -Tpng -Kdot
  digraph G{
    6->5
    6->4
    5->4
    5->3
    4->3->2
    4->2
    3->1
    }
#+END_SRC

#+RESULTS:
[[file:fbi.png]]

n 个顶点, 2n-4 条边

* 矩阵链乘法
$A_{p\times q}\cdot B_{q\times r}=C_{p\times r}$ 用标量乘法的次数来表复杂度的话, 该矩阵乘法的代价 $pqr$
** 动态规划
1. 递归公式 $m_{i,j}$ 表示 $A_iA_{i+1}\cdots A_j$ 的代价
\[m_{i,j}=\begin{cases}0,&i=j\\min\{m_{i,k}+m_{k+1,j}+p_{i-1}p_kp_j\},&i< j\end{cases}\]

#+BEGIN_EXAMPLE
  MATRIX-CHAIN-ORDER(p)
  1   n = p.length - 1
  2   let m[1,2,...,n;1,2,...n] and s[1,2,...,n-1;2,3,...,n] be a new array
  3   for i = 1 to n
  4       m[i, i] = 0
  5   for l = 2 to n
  6       for i = 1 to n - l + 1
  7           j = i + l - 1
  8           m[i, j] = ∞
  9           for k = 1 to j - 1
  10              q = m[i, k] + m[k + 1, j] + p_{i-1}p_kp_j
  11              if q < m[i, j]
  12                  m[i, j] = q
  13                  s[i, j] = k
  14   return m and s
#+END_EXAMPLE

** 练习
*** 
$$((A_1A_2)((A_3A_4)(A_5A_6)))$$
*** 
#+BEGIN_EXAMPLE
MATRIX-MULTIPLY(A, B)
1   if A.cols != B.rows
2       error "维度错误"
3   else let C be a new A.rows X B.cols matrix initialise with 0
4       for i  = 1 to A.rows
5           for j = 1 to B.cols
6               for k = 1 to A.cols
7                   C[i][j] += A[i][k]*B[k][j]
8   return C

MATRIX-CHAIN-MULTIPLY(A, s, i, j)
1   if i == j
2       return A[i]
3   return MATRIX-MULTIPLY(MATRIX-CHAIN-MULTIPLY(A, s, i, s[i][j]), MATRIX-CHAIN-MULTIPLY(A, s, i, s[i][j]))
#+END_EXAMPLE

*** 
$$P(n+1) = \sum_{j=0}^{n}P(j)P(n+1-j)=P(n)+\sum_{j=1}^{n-1}P(j)P(n+1-j)\geqslant P(n)+\sum_{j=1}^{n-1}P(j)P(n-j)=2P(n)\geqslant 2*2^n=2^{n+1}$$
*** 
略
