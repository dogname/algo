#+html_head: <link rel="stylesheet" type="text/css" href="/home/ticks/Public/org_style.css" />
#+title: 动态规划(dynamic programing)
* 钢条切割
给长度为 n 的钢条和一个价格表 $p_i$, 如何切割收益最大
** 普通递归
收益 $r_n=max(r_i+r_{n-i})$
#+BEGIN_EXAMPLE
CUT-ROD(p, n)
1   if n == 0
2       return 0
3   q = -1
4   for i = 1 to n
5       q = max(q, p[i] + CUT-ROD(p, n-i))
6   return q
#+END_EXAMPLE
$$T(n)=1+\sum_{i=0}^{n-1}T(i) = 2^n$$

** 动规
#+BEGIN_EXAMPLE
CUT-ROD(p, n, r)
1   if r[n] > 0
2       return r[n]
3   if n == 0
4      return 0
5   q = 0
6   for i = 1 to n
7       q = max(q, p[i] + CUT-ROD(p, n-i))
8   r[n] = q
9   return q
#+END_EXAMPLE

或者
#+BEGIN_EXAMPLE
CUT-ROD(p, n)
1   let r[1...n] be a new array
2   r[0] = 0
3   for i = 1 to n
4       q = 0
6       for j = 1 to i
7           q = max(q, p[j] + r[i-j])
8       r[i] = q
9   return r[n]
#+END_EXAMPLE

** 子问题图
#+BEGIN_SRC dot :cmdline -T png -Kdot :file subG.png
  digraph G{
    4->3->2->1->0
    4->2
    4->1
    4->0
    3->1
    3->0
    2->0
  }
#+END_SRC

#+RESULTS:
[[file:subG.png]]

** 练习
*** 
$T(0)=1=2^0$
假设 n 小于 N 的时候满足 $T(n)=2^n$
则$$T(N)=1+\sum_{j=0}^{N-1}T(j)=1+\sum_{j=0}^{N-1}2^j=1+(2^N-1)=2^N$$
*** 
$p = {0.5, 1, 1.5, 12, 20}, n =8$

贪心结果 5+3, 收益 20+1.5=21.5

最优 4+4, 收益 12+12=24
***  
#+BEGIN_EXAMPLE
CUT-ROD(p, n, cost)
1   let r[1...n] be a new array
2   r[0] = 0
3   for i = 1 to n
4       q = 0
6       for j = 1 to i - 1
7           q = max(q, p[j] + r[i - j] - cost)
8       if(q < p[i] 
9           q = p[i]
10      r[i] = q
11  return r[n]
#+END_EXAMPLE

*** 
略
*** 
#+BEGIN_EXAMPLE
fbi(n)
1   res[3] = {1, 1, 2}
2   for(int i = 3; i < n; ++i)
3       res[i % 3] = res[(i + 1) % 3]+res[(i + 2) % 3]
4   return res[(n - 1) % 3]
#+END_EXAMPLE

#+BEGIN_SRC dot :file fbi.png :cmdline -Tpng -Kdot
  digraph G{
    6->5
    6->4
    5->4
    5->3
    4->3->2
    4->2
    3->1
    }
#+END_SRC

#+RESULTS:
[[file:fbi.png]]

n 个顶点, 2n-4 条边
